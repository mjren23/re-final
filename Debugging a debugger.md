## Debugging a debugger:

 <center> <font size="+2">Abstract</font></center>

*GDB* is a popular debugging tool used to investigate a programs execution and address space. As
debugging has grown in usage, CPU architectures have developed infrastructure to handle
debugging at a hardware level to allow for faster breakpoints with lower overhead. GDB’s usage
of these breakpoints, however, appears to be lacking some critical abilities to persist the CPU’s
debugging state across context switches and across various CPUs.

Most notably, in syscalls and signal handlers, addresses which are written by the kernel are
ignored by the user-land GDB watchpoints. We propose a means of fixing this issue by patching
GDB’s implementation of hardware watchpoints to allow for persistence of the debugging state.
Such design overhauls have been discussed by researchers over the last decade, and we hope to
expand upon these ideas to provide users the ability to investigate memory reliably and
accurately without needing a deep knowledge of the context switches involved in program
execution.

In this paper, we will investigate why GDB maintains this behavior while also developing
an understanding of how debuggers at-large function. We will illustrate a series of patches which attempted to allow for a general user population to set breakpoints and
watchpoints on memory with assurance that any read, write, or execution of that memory
(whether in kernel or userland) results in a break in GDB’s run. 

 <center> <font size="+2">Background</font></center>


**How a debugger works**

Given the exstensive memory access a debugger requires, userland services are not sufficient to build a worthwhile debugger. For this reason, most modern operating systems offer a library of system calls intended for *tracing* the execution of a program along with its memory contents. 

In linux, the ```ptrace()``` function is responsible for attaching one process (the *tracer*) to another process (the *tracee*) for the purposes of debugging and memory examination/manipulation.

The ```ptrace()``` system call works by redirecting signals/interrupts generated by the *tracee* to be handled by the *tracer*, forcing the halting of execution of the *tracee* and allowing the *tracer* to interact with the kernel to examine and change the memory contents of the *tracee*. Then, the *tracer* can end the signal handling and hand execution back to the *tracee*.

*GDB* and other debuggers make extensive use of this system call to step through and examine program execution. Effectively, *GDB* is a convenient, user-friendly wrapper for the ```ptrace()``` syscall which offers a dense suite of program analysis and adjustment tools.

**Software breakpoints/watchpoints**

One of *GDB*'s most useful features is the ability to set breakpoints in execution. Users can denote particular instruction addresses at which they want the program to halt. 

To accomplish this, *GDB* actually injects code into the program using ```ptrace()``` and replaces the line you are investigating with a command which will cause a signal and halt execution at the desired line.

Because this is implemented programattically, the number of software breakpoints is theoretically unbounded (outside of memory restrictions).

However, this forced halting (known as a *breakpoint*), only has the power to halt at the execution of a line and does not detect memory access to particular addresses. Thus, *GDB* offers a second type of halting (known as a *watchpoint*) which halts at memory access to a particular address. 

Similar to software breakpoints, watchpoints can be implemented programatically by simply checking the state of the memory address after each line of execution, but this adds an absurd amount of overhead to the program and makes such an approach infeasible for computationally complex programs.

**Hardware breakpoints/watchpoints**

To combat this overhead, CPU architecures have began providing special debugging registers which allow for comparisons between addresses in the data bus and the addresses in the debug registers to be handled directly at the CPU. For this paper, we will investigate such features in the x86 architecture. 

In this case, 8 debug registers are provided by the CPU, but 2 of these are fully reserved by the architecture, so we will examine the remainign 6 registers.

![Intel Debug Registers](https://i.ibb.co/9VDBQdG/debug-registers.jpg)

<sup>Source: </sup><a href="https://www.intel.com/content/dam/support/us/en/documents/processors/pentium4/sb/253669.pdf"><sup>Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2</sup></a>


The first 4 registers (```DR0``` - ```DR3```) store the 32-bit addresses which indicate which addresses in memory we are setting a watchpoint on. This also illustrates one limitation with hardware watchpoints, they have a limited number specified by the CPU architecture. 

As noted, the next two registerrs (```DR4``` - ```DR5```) are reserved by the CPU.

The following two registers (```DR6``` - ```DR7```) are used to control the behavior of these watchpoints (the only control bits we will worry about are in ```DR7```). 

 <center> <font size="+2">The Problem with GDB</font></center>

**Local vs. Global Watchpoints**

**Proposed Solutions**

**Our Proposal**

 <center> <font size="+2">Patching GDB</font></center>

**Dynamic Analysis**

**Static Analsysis**

**Updating the Binary**


 <center> <font size="+2">Back to the Drawing Board</font></center>

In hindsight, an immediate investigation of *GDB*'s handling of watchpoints was not the most effective method of analysis. After doing this investigation we decided that we should have illustrate that setting the ```global detect``` bit in ```DR7``` would have even produced the result we desired. This is to say, our goal from the outset was to get *GDB* to set this bit, but even with this bit set, the problem does not appear to be solved. 

To narrow down the issues we were facing, we wrote a short script that was intended to examine whether or not a watchpoint with ```global detect``` enabled would be able to detect kernel level changes. 

**Proof of Concept**

**The Takeaway**

As new reverse engineers, this is an important lesson in the flow of program analysis - narrow down the problem, then expand to a larger code base. The testing script should have been written long before *GDB*'s source code was examined as this would have saved us a great deal of time exploring a route that was to no avail. 

 <center> <font size="+2">Conclusion</font></center>
